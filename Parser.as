/*  Parser  The class takes the unconventional (for AS3) step of defining a bunch of  "symbol" objects like this:      { bpow:an_int, nud: function() { ... }, led:function(){ ... }, std:function() { ... } }    Some symbols have only nud, some have only led, some have both, and some have only std.   (These are abbreviations for Null Denotation, Left Denotation, and Statement Denotation,  in the terminology of Pratt parsing )    The symbols are all conceptually similar, but there's a lot of variability in the  nud and led functions, and I didn't want to define 20-odd different classes for  what's basically a data structure.  */package org.sixsided.scripting.SJS {    import org.sixsided.scripting.SJS.Inspector;        /*      pseudo-types:        token:    {type, value, from, to}        symbol:   {nud, led, std, bpow, codegen} associated with an id            parsenode: token + symbol + id          - could set the prototype of each token to the symbol with the matching id          - could make a ParseNode class per symbol and construct one instance around each token read        the id of a parseNode references            */  public class Parser {      public var symtab:Object = {};      public var scopes:Array = [[]]; // just names      public var tokens:Array = [];      public var token:Object = null;      public var token_idx:int = 0;        public var source_code:String;      var generated_code:Array = [];      private var ID_END    :String = '(end)';      private var ID_LITERAL:String = '(literal)';      private var ID_NAME   :String = '(name)'; // we attach IDs to lexer tokens      private var T_NAME    :String = 'name';  // tokens from the lexer have type, value, from, and to      private var END_TOKEN :Object = {id:ID_END, toString:function():String{return "*END*";}};             public var ast:Object;    function isArray(o:*){        return(o is Array); // this'll do for AS3      // return "[object Array]" == Object.prototype.toString.apply(o);      // this is the Miller Device, for browser js    }      /***********************************************************      *      *    PUBLIC API      *      *     opcode = (new Parser()).parse(src).codegen();      *     opcode = (new Parser()).codegen(src);      *      ***********************************************************/      public function Parser() {          init_symbols();      }            // usage:  my_VM.load (      //                      my_Parser.parse(js_code).codegen()      //         ).run();      // TBD: encapsulate this in an Interpreter class, mebbe.        public function parse (src:String):Parser {            // trace('"""', src, '"""');            tokens = [];            token = null;            token_idx = 0;              source_code = src;                tokens = Lexer.tokenize(src);            //try {                next();                ast = statements();            //} catch(e) {            //              //}            return this;        };        public function codegen(src:String = null):Array{          if(src) { parse(src); }          log('##', dump_ast());          generated_code = [];          //try {              C(ast);          //} catch(e) {          //    throw("Parser::codegen: " + e);          //}          log('##', generated_code.join(" "));          return generated_code;        };                // Traverse the parse tree in preorder and output it in a         // postfix notation with lisp-like parenthesization        public function dump_node(tree:Object) {            function dnr(n:*) {                if(!n) return '';                                 var ret:String = ''                if(n is Array) {                    ret += '[';                     // '[' and ']' for arrays, such as argument arrays                    for each (var v in n) {                        ret += dnr(v) + ', ';                    }                    ret += ']'                } else if( n.first ){               // '(' and ')' for node children                    ret = '(';                    ret += n.value == '(' ? '@CALL' : n.value;                    ret += ' ' + dnr(n.first);                    ret += ' ' + dnr(n.second);                    ret += ' ' + dnr(n.third);                    ret += ')';                } else {                    return n.value;                }                return ret;            }            return dnr(tree);        }                public function dump_ast():String{          return dump_node(ast);        };                public function codegen_string():String {          this.codegen();          return generated_code.join(' ');        };                  /*    Operator precedence:        160    Primary [] {x:y} () f(x) new x.y x[y] <></> @ :: ..          150    Postfix x++ x--        140    Unary ++x --x + - ~ ! delete typeof void        130    Multiplicative * / %        120    Additive + -        110    Bitwise shift << >> >>>        100    Relational < > <= >= as in instanceof is         90    Equality == != === !==         80    Bitwise AND &         70    Bitwise XOR ^         60    Bitwise OR |         50    Logical AND &&         40    Logical OR ||         30    Conditional ?:         20    Assignment = *= /= %= += -= <<= >>= >>>= &= ^= |=         10    Comma ,    */    //                          reserved words stay reserved -- operators      // debug cruft      var xd:int = 0 ;      var tracing:Boolean = false;            protected function extend(a, b) { for(var i in b) a[i] = b[i]; return a;}          protected function log(... msg) {          var indent:String = '                                    '.slice(0, xd * 4);          if(tracing) trace(indent, msg.join(' '));      }      public function trace_off() { tracing = false; }      public function trace_on() { tracing = true; }      protected function _symbol_tostring() {        return "(" + this + ")";               }      protected function next(id=null){         /*          var nt = tokens[token_idx];          if(token) log( (id ? '[' + id + '] ' : '') + '"' + token.value + '" --> ' + (nt ? ('"' + nt.value + '"') : ''));*/              if(id && token.id != id) {              log('Parser::next expected to be on "' + id + '" but was on "' + dump_node(token) + '"');              if(id == ';') throw new Error('missing a semicolon after ' + offending_line(token.from));              throw new Error('unexpected ' + token.id + ':' + token.value + ' in next()');          }                        var pt = token;          token = tokens[token_idx++];                    if(token_idx > tokens.length) return token  = END_TOKEN;                  if(token.type == 'name') {              if(symtab.hasOwnProperty(token.value)) {                  token.id = token.value;              } else {                  token.id = ID_NAME;              }              // log('name parsed:', token.id, token.value);          } else if(token.type == 'string' || token.type == 'number') {              token.id = ID_LITERAL;              // lexer transforms numbers to floats          } else /*operator*/ {              token.id = token.value;              // log('op parsed:', token.id);          }                  return extend(token, symtab[token.id]); // clone FTW.  So what if it might be slow?   handles the this binding simply.      }    protected function infix_codegen(opcode) {       return function() { C(this.first); C(this.second); emit(opcode); };     }    protected function prefix_codegen(opcode) {       return function() { C(this.first); emit(opcode); };     }    protected function symbol(sym) {      if(symtab.hasOwnProperty(sym)) return symtab[sym];      return symtab[sym] = {}    }        protected function infix(sym, bpow, opcode) {          return symtab[sym] = {                                  led:function(lhs) {                                          this.first = lhs;                                          this.second = expression(this.bpow);                                          return this;                                    },                                  codegen:infix_codegen(opcode),                                  bpow:bpow          };      };          // TBD: let a script function say  parser.user_infix('x', 160, newPoint);   p = 30 x 60;  function newPoint(a,b) { return new Point(a,b); }    //public function user_infix(sym:String, bpow:Number, callback:VmFunc) {    //  return symtab[sym] = {    //    led:infix_led,    //    bpow:bpow,    //    codegen:    //      function(){    //        // 23 @ 42  -> VAL newPoint [ 23 42 ] CALL    //        emit(VM.VAL);    //        emit_lit(this.id);    //        emit(VM.MARK);    //        C(this.first);    //        C(this.second);    //        emit(VM.ARRAY);    //        emit(VM.CALL)    //      }          //}    protected function prefix(sym, bpow, opcode) {         var s:Object = symbol(sym);        s.bpow = s.bpow || 140;  // don't want infix - to get a higher precedence than *, for example.        s.nud = function() {            this.first = expression(0);            return this;        };        s.codegen = prefix_codegen(opcode);         }  protected function assignment(id:String, bpow:int, operation:String=null) {        var sym = symbol(id);        sym.bpow = bpow;                    var mutate = operation ? true : false;    // operation is "+" for +=, "-" for -=, etc; and null for "=".               sym.led = function(lhs) {                                    this.first = lhs;                                    this.second = expression(this.bpow - 1 );  /* drop the bpow by one to be right-associative */                                    this.assignment = true;                                    return this;                                };        sym.codegen = function(){                                    if(mutate) {                                                                            // do the operation     // if it's "x += 3", then...                                        C(this.first);          // LIT x                                        C(this.second);         // VAL 3                                        emit(operation);        // ADD                                    } else {                                        // just emit the value   // if it's "x = 3", then:  LIT 3                                        C(this.second);                                    }                                    //assign it to the lhs                                    C(this.first, true);        // LIT x                                                 if(this.first.id=='.') {                                        // e.g. for "point.x += 3", change the opcode from:                                        //    VAL point LIT x GETINDEX LIT 3 ADD    VAL point LIT x GETINDEX                                        // to:                                                      ^^^                                        //    VAL point LIT x GETINDEX LIT 3 ADD    VAL point LIT x PUTINDEX                                        remit(VM.PUTINDEX); // PUTINDEX consumes the stack (val obj key)  and does obj[key] = val;                                    } else {                                        emit(VM.PUT);                                     }                                    // PUT leaves the value onstack for multiple assignment, DROP it as we come out of the nested assignments                                    need_drop();                                };        return this;    }             // function _symbol_tostring(){      //     return "(" + [this.id,this.first,this.second].join(' ') + ")";       // }          protected function constant(id, v) {            return symtab[id] = {                nud:function(){ this.value = v; return this; },                  bpow:0,                 codegen:function(){                            emit_lit(this.value);                        }            };       };    protected function expression(rbp){          xd++;          // grab first token and call its nud          log('expression(', rbp, ')  // ', dump_node(token), '...');          var t = token;          next();          if(t.nud == undefined) {            throw new SyntaxError("Unexpected " + t.id + " token:  ``" + t.value + "''" + " at char:" + t.from + "-" + t.to + " || line: " + offending_line(t.from));          }          var lhs = t.nud();          log('"' + dump_node(t) + '".nud() => ' + lhs);          // shovel left hand side into higher-precedence tokens' methods          while (rbp < token.bpow){              t = token;              next();                            log('"' + dump_node(t) + '".led(' + dump_node(lhs) + ') -> ');              if(!t.led) {                 throw new SyntaxError(t + 'has no led in ' + source_code);              }              lhs = t.led(lhs);               //log('  ' + dump_node(lhs));                        }           log('=> ' + dump_node(lhs));          xd--;          return lhs;      }                         protected function block() {          var t = token;          next("{");          return t.std();      };          protected function statement(){          var ret, t = token;          if(t.std) {              next();              log('std ' + t);              ret = t.std();              log('-> ' + t);               return ret;          }          log('no std; expression...');          var xstmt = expression(0);          // log(xstmt);          if(!(xstmt.assignment || xstmt.id == '(')) {               throw( new Error('invalid expression statement :' +  offending_line(t.from)) );          } // neither assignment nor function call          next(';');           return xstmt;      }                protected function statements(){          var stmts = [];          for(;;) {              if(token.id == '}' || token.id == ID_END) break;              stmts.push(statement());          }          return stmts;      }         //----------------------- CODE GENERATION ---------------------    protected function emit(... opcodes) {      //var msg = '';      for(var i=0; i<opcodes.length;i++){          //log('#', opcodes[i]);          generated_code.push(opcodes[i]);      }    }    protected function remit(token){      generated_code.pop();      emit(token);    }    protected function emit_lit(v){      emit('LIT');      emit(v);    }    protected function emit_prefix(node, op){      C(node); emit(op);    }    protected function emit_infix(n1, n2, op) {      C(n1); C(n2); emit(op);    }    // usage = j = emit_jump_returning_patcher(VM.JUMPFALSE); ... emit a bunch of stuff ... j();    // opcodes are:  JUMP|JUMPFALSE <offset>    // The offset is from the address of JUMPFALSE, not of <offset>  protected function emit_jump_returning_patcher(opcode) {      emit(opcode);      var here = generated_code.length;      var patcher = function() {         generated_code[here] = generated_code.length - here - 1; // decrement to factor in the <offset> literal      }      emit('@patch');      return patcher;                }                      protected function backjumper(opcode) {    // opcodes emitted:  JUMP|JUMPFALSE <offset>    // currently uses only JUMP, but will need JUMPFALSE to support "do { ... } while(test)" semantics    (TBD)      var here = generated_code.length;      return function() {         emit(opcode);         var offset = here - generated_code.length - 1; // decrement to factor in the <offset> literal        log(" @ @ @ EMIT BACKJUMP: ", opcode, offset);        emit(offset);       }  }                private var drops_needed:int = 0;                 // fixme: this seems really incorrect.  take multiple assignment out?      private function need_drop() { drops_needed++; }  // see assignment()  ^^^... no, make codegen return and concat arrays recursively        protected function C(node, is_lhs=false) {         //log('C', node);      //if(isArray(node)) { // statements      if(node is Array) { // statements        for(var i=0;i<node.length;i++) {            C(node[i], is_lhs);            // we might need to drop some leftover values from a multiple assignment            while(drops_needed > 0) { emit(VM.DROP); drops_needed--; }        }      } else {        if(!node.codegen) {           throw new SyntaxError('No Codegen for '+node.name+'#'+node.id+'='+node.value);         } else {          node.codegen(is_lhs);        }      }    }            // for code like " a { b c } d  ", return [a, [b, c], d]    function codegen_block(node:Object){      var orig_code = generated_code;      generated_code = [];/*    log('compiling block');*/      C(node);      var block_code = generated_code;      generated_code = orig_code;/*    log('returning block', Inspector.inspect(block_code));*/      return block_code;          }        function C_hash(o){      for(var k in o) {        emit('LIT', k);        C(o[k]);      }    }/* Note: it might be worth storing the symbol table as an {id:symbol} hashif I decide to put vars on the stack rather than in hash tables, b/c the symbolcould store the var's stack index.  maybe?    Might be worth investigation for a speed bump later.  AS3 hash lookups are fast,    but I might eliminate the hashes entirely and throw everything on the stack.  Meh.*/      function scope_define(name){        // used by: function, var/*        log('scope_define', name);*/        for each(var existing_name:String in scopes[0]) {          if(existing_name == name) {            throw new Error('tried to redefine variable ' + existing_name + ' in line "' + offending_line() + '"');          }        }        scopes[0].push(name); // FIXME, throw an error if it's already defined       }      function scope_push(){        scopes.unshift([]);      }      function scope_pop(){        scopes.shift();      }          function parse_argument_list() {        log('parse_argument_list     // ' + token.value);        var args = [];                if(token.id == ')') return args;  // bail if args list is empty; caller is responsible for consuming )                while(true) {            args.push(expression(0));            if(token.id != ',') { // this would be the closing )                break;             }            next(',');        }        log('arguments list:', dump_node(args));        return args;    }            private var getAnonFuncName_id:int = 0;    function getAnonFuncName() {      return 'anon' + getAnonFuncName_id++;    }          function init_symbols() {/*    In js, could dump parse tree with: 		Array.prototype.toString = function(){ return "[" + this.join(',') + "]"; };      	Function.prototype.toString = function() { return "*CODE*"; }	  No go in AS3.*/            //constants      constant('true', true);      constant('false', false);      //primitives      symtab[ID_NAME] = {          nud:function(){return this;},          toString:function(){return this.value;},          codegen:function(am_lhs) {  emit(am_lhs ? 'LIT' : 'VAL',  this.value); }  // need a reference if we're assigning to the var; the value otherwise.      };      symtab[ID_LITERAL] = {          nud:function(){return this;},          toString:function(){return this.value;},          bpow:0,          codegen:function() { emit_lit(this.value); } // tbd test w/ lexer change to parse numbers      };        //assignment      // fixme: and here we see why V K SWAP SET is more consistent than V K PUT      assignment('=', 20);      assignment('+=', 130, VM.ADD);      assignment('-=', 130, VM.SUB);      assignment('*=', 130, VM.MUL);      assignment('/=', 130, VM.DIV);      assignment('%=', 130, VM.MOD);      prefix('!', 140, VM.NOT);      infix('+', 120, VM.ADD);      infix('-', 120, '*minus*');      prefix('-', 120, '*unary minus*');      // tbd: different codegens by arity?      symtab['-'].codegen = function() {           if(this.second)           emit_infix(this.first, this.second, VM.SUB);          else {              emit_prefix(this.first, VM.NEG);          }      };              infix('*', 130, VM.MUL);      infix('/', 130, VM.DIV);      infix('%', 130, VM.MOD);            // comparison      infix('<', 100, VM.LT);      infix('<=',100, VM.LTE);      infix('>', 100, VM.GT);      infix('>=',100, VM.GTE);      infix('==', 90, VM.EQL);        infix('&&', 50, VM.AND);       infix('||', 40, VM.OR);              infix('.', 160, VM.GETINDEX); // a.b.c indexing operator       //indexing       // RHS [k(1) dot... k(n-1) dot] dict k(n) put       // where dot has stack effect ( o k -- o[k] )       // a.b.c.d = e -- $ e $a # b dot # c dot # d dot dict        symtab['.'].codegen = function(is_lhs /* assignment? */){           // log('.', this.first.value, this.second.value, is_lhs ? 'LHS' : 'RHS');           if(this.first.id != '.') {               C(this.first, false); // use VAL           } else {               C(this.first, true);  // use LIT           }           C(this.second, true); // treat as LHS until the last item in the dot-chain           log('# emit ' + VM.GETINDEX);           emit(VM.GETINDEX);       };                            symbol('new');    symbol('new').bpow = 160;    symbol('new').nud = function() {        if(token.type != T_NAME) throw("Expected name after new operator, got " + token.value + " in: " + offending_line());        this.first = token;        next(/*constructor*/);        next('(');        this.second = token.id == ')' ? [] : parse_argument_list();        next(')');        return this;    }    symbol('new').codegen = function(){        emit_lit(this.first.value);        emit(VM.MARK);        C(this.second);        emit(VM.ARRAY);        emit(VM.NATIVE_NEW);   // ( constructor [args] -- instance )    }                      symtab['('] = {               bpow:160,            // subexpression            nud:function(){                var expr = expression(0);                next(')');                return expr;            },              // function call            led:function(lhs){                this.first = lhs;                // will be on '('                this.second = parse_argument_list();                next(')');                return this;            },                    codegen:function() {              C(this.first);              emit(VM.MARK);              C(this.second);                emit(VM.ARRAY);              emit(VM.CALL);            }      };              symtab[')'] = { bpow:-1 };    // ?? fixme      symtab['function'] = {        std:function(){            var fn_name = token;            var args = [];             next(/*name*/);       // <-- this is correct                  if(fn_name.type != T_NAME) { throw("Invalid function name '" + fn_name.value + "' on line: " + offending_line()); }                        scope_define(fn_name.value);            scope_push();             this.scope = scopes[0]            next('(');                  if(token.id != ')') {                args = parse_argument_list();/*                for(;;) {                    log(token);                    if(token.type != T_NAME) throw new Error('unexpected ' + token.id + ' in fn args');                    args.push(token);                    next();                    if(token.id != ',') break;                    next();                }*/            }            next(')');            next('{');            var body = statements();            next('}');                    scope_pop();                   this.first = fn_name;            this.second = args;            this.third = body;                         return this;        },        nud:function(){},        bpow:0,                codegen:function() {          // function f(a) { var v; trace(v); }  -->  LIT f MARK LIT a LIT v LOCAL ARRAY [ LIT trace MARK LIT v ARRAY CALL ] DEF          emit_lit(this.first.value);          emit(VM.MARK);          // args          C(this.second, true);                              emit(VM.ARRAY);                    // tbd: fix this hack to create locals at the beginning of a function's code block          var body = codegen_block(this.third);          for each(var v in this.scope) { body.unshift(VM.LOCAL); body.unshift(v); body.unshift(VM.LIT); }          emit(VM.LIT);          emit(body);          emit(VM.DEF);        }           };      symtab['return'] = {          bpow:0,          std:function(){              this.first = expression(0);              next(';');              return this;          },          codegen:function() {                   C(this.first);                   emit(VM.RETURN);              }      };          symtab['['] = {          nud:function(){              var a = [];              for(;;){                  a.push(expression(0));                  if(token.id != ',') break;                  next(',');              }              next(']');              this.first = a;              return this;          },          toString:function(){ return "(array " + this.first + ")"; },          bpow:160,          codegen:function() { emit('MARK'); C(this.first); emit('ARRAY'); }      };      symtab['{'] = {          std:function(){            var a = statements();           next('}');           return a;         },          nud:function(){            var key, value, obj = {};            for(;;) {              key = token;              next();              next(':');              value = expression(0);              obj[key] = value;              //next(); // --> , or }              if(token.id != ',') break;              next();            }            next('}');            this.first = obj;            return this;         },         codegen:function() { emit('MARK'); C_hash(this.first);  emit('HASH'); }      };                    // control structures                    //functions      symtab['if'] = {          std:function(){              next('(');              var cond = expression(0);              next(')');              next('{');              var then_block = statements();              next('}');              this.first = cond;              this.second = then_block;                      // trace(token);              if(token.id == ID_NAME && token.value == 'else') {                next(); // skip else                var t = token;                this.third = t.value == 'if' ? statement() : block(/*eats initial { */);                  //next('}'); // block also eats closing }                // what if the next statement's another if?              }              return this;          },          bpow:0,          codegen:function() {              C(this.first); // test                        var patch_if = emit_jump_returning_patcher(VM.JUMPFALSE);              C(this.second);              patch_if();                                      if(this.third) {                var patch_else = emit_jump_returning_patcher(VM.JUMP);                patch_if();                C(this.third);                patch_else();  // rewrite @else to point after "if{...}else{...}" instructions.              }            }              };      symtab['while'] = {          std:function(){              next('(');              var cond = expression(0);              next(')');              next('{');              var block = statements();              next('}');              this.first = cond;              this.second = block;              return this;          },          bpow:0,          codegen:function() {              var emit_backjump_to_test:Function = backjumper(VM.JUMP);              C(this.first);              var patch_jump_over_body:Function = emit_jump_returning_patcher(VM.JUMPFALSE);                            C(this.second);              emit_backjump_to_test();              patch_jump_over_body();            }                };      symtab['for'] = {          std:function(){           // for (initial-expr ; test-expr ; repeat-expr ) { body }           next('(');           var init = expression(0);           next(';');           var test = expression(0);           next(';');           var modify = expression(0);           next(')');           next('{');           var block = statements();           next('}');           this.first = [init,test,modify]           this.second = block;          },          bpow:0,          codegen:function(){              //for(i=0;i<10;i += 1) { trace(i); }                            C(this.first[0]);                         // i=0              var backjump_to_test = backjumper(VM.JUMP);              C(this.first[1]);                         // i<10              var jumpfalse_to_here = emit_jump_returning_patcher(VM.JUMPFALSE);              C(this.first[2]);                         // i += 1                C(this.second);                           // trace(i);              backjump_to_test();                       // } --> JUMP to i < 10              jumpfalse_to_here();                      // patch the JUMPFALSE after "i<10"           }      }      symtab['var'] = {          std:function(){/*            trace('* var statement');*/              var e, names = [];              for(;;){                  e = expression(0);                  if(e.id != '=' && e.id != ID_NAME) {                       throw new Error('Unexpected intializer ' + e + ' in var statement :' + offending_line(this.from));                  }                  names.push(e);                  // here's one place where static typing would have saved me trouble:/*                  scope_define(e.id == 'NAME' ? e.id : e.first.id)*/                  scope_define(e.type == T_NAME ? e.value : e.first.value)                  if(token.id != ',') break;                  next(',');              }              next(';');              this.first = names;/*              trace('* --- end var statement');*/              return this;          },          bpow:0,          toString:function(){              return '(var '+ this.first + ')';          },          codegen:function(){            /*            trace("var codegen doesn't do anything; it's just a marker.");*/          }      };                   }     // return the text of the source-code line containing a given character offset (which offset we originally got from the lexer)     private function offending_line(near:int=-1){       var line_start:int, line_end:int;       var nlChar = {"\n":true, "\r":true}       if(near<0) near = token.from;       // back up to the start of the line       for(line_start = near; line_start >= 0 && !nlChar[source_code.charAt(line_start)]; line_start--);       // walk forward to the end of the line       for(line_end = near; line_end < source_code.length && !nlChar[source_code.charAt(line_end)]; line_end++);       return source_code.substring(line_start,line_end);            }  } // class        }