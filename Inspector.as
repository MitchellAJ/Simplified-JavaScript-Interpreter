package org.sixsided.scripting.SJS {	import flash.display.DisplayObjectContainer;	import flash.display.DisplayObject;	import flash.utils.getQualifiedClassName;		public class Inspector {	  	  public static function jsonify(obj) {	    return Inspector.inspect(obj, false);    }    		public static  function inspect(obj, multiline:Boolean=false):String {			if(null == obj) return '*null*';						function keys(o) {				var k:Array = []				for(var i:* in o) k.push(i);				return k;			}						var depth = 0;			var whitespace = "                                                                                                ";			function whitepad(){				if(multiline) out += "\n" + whitespace.substr(0, depth*4)			}			var obj_stack:Array = [];			var key_stack:Array = [keys(obj)];			var seen:Array = [obj];			var out:String = (obj is Array)  ? '[' : '{';						if(typeof(obj) != 'object') return obj;						obj_stack.push(obj);						while(obj_stack.length){				whitepad();				var o = obj_stack[0];						  // Possible improvement: spit out toString of object								// is it a for/in iterable object, typically {} ?  Do we have keys left?				if(key_stack[0].length) {					var k = key_stack[0].shift()					if(!(o is Array)) out += k + ':'; 					          var classname = getQualifiedClassName(o[k]).split('::').pop();   // returns path.to.package::Class										if(classname == 'Object' || classname == 'Array') {						depth++;						if(seen.indexOf(o[k]) != -1) { out += '*recursion*'; continue; }						seen.push(o[k])						key_stack.unshift(keys(o[k]));						obj_stack.unshift(o[k])						out += o[k] is Array ? ' [' : ' {';					} else {						out += o[k];						if(key_stack[0].length) out += ', '					}				} else { // out of keys					depth--;					out += o is Array ? ' ] ' : ' } ';					key_stack.shift();					obj_stack.shift();				}						}			return out;		}				public static function inspectDisplayObject(dob:DisplayObject):String{			var indentStr = '    ';			function ido_r(dob:DisplayObjectContainer, indentation:String = '') {				var out:String = getQualifiedClassName(dob) + " @ " + dob.x + ", " + dob.y + " ( " + dob.width + " x " + dob.height + " )";				if(dob is DisplayObjectContainer) {										for(var i:int = 0; i < dob.numChildren; i++) {						out += "\n" + ido_r(dob.getChildAt(i), indentation + indentStr);					}				}				return out;			}			return ido_r(dob)		}	}///class}//pkg