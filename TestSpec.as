/*specs DSL  spec( js_source, {    parse: stringified parse tree,    code: stringified VM opcode,    globals: { object that globals should match }    [inject_globals: {globals to set up VM with before running} ]*/package org.sixsided.scripting.SJS {  import org.sixsided.scripting.SJS.*;      import flash.geom.Point; // for test fixtures  import flash.display.Sprite; // for testing 0-arg native new      public class TestSpec {   protected var specs:Array = [];   protected var spec_result:Array = [];   protected var spec_pass:Boolean = true;   protected var test:String='none';        // does the tree 'value' contain all the leaves in the tree 'pattern'?     public function structureContains(value:*, pattern:*):Boolean {      function haz_r(a:*, exp:*):Boolean {        //scalar?        if (typeof(exp) != 'object') {          return a == exp;        }        //complex:        var match:Boolean = true;        for (var i:* in exp) {          match = match && a.hasOwnProperty(i) && haz_r(a[i], exp[i]);        }        return match;      }      return haz_r(value,pattern);    }    //var value:* = '"this" is bound to InterpreterSpec';        public function TestSpec() {      init_specs();    }            public function spec(src:String, assertions:Object):void {      specs.push({src:src, assertions:assertions});    }             public function run_specs():void {      //test_callScriptFunc();      var specs:Array = this.specs.reverse();      for (var i:Object in specs) {        runSpec(specs[i]);      }    }             public function start_test(src:String):void {      spec_result.push('TEST: ' + src);      spec_result = [];      spec_pass = true;    }             public function result(pass:Boolean, msg:String):void {      spec_pass = spec_pass && pass;      if(pass) return;      spec_result.push((pass ? 'PASS' : '! ! ! FAIL') + ': ' + msg);    }         public function end_test():void {      if(spec_pass) return;      for each(var r in spec_result) trace(r);      trace('---------------------------');    }        //function diffString(a:String,b:String):String {    //  return b;    //}    //function test_callScriptFunc() {    //  var src:String = "function trex() { trace('T-rex!'); }";    //  var opcode:Array =  (new Parser()).parse(src).codegen();    //  var vm:VM = new VM();    //  vm.load(opcode);    //  vm.run();    //  vm.callScriptFunction('trex');    //}     public function runSpec(spec:Object):void {            start_test(spec.src);            var parser:Parser;            var vm:VM;            var code_result:Array;            var pass:Boolean = true;                        trace('---------------------------');            trace('SOURCE:', spec.src);                        try {           // evaluation                try {                      parser  = new Parser().parse(spec.src);                      trace('AST: ', parser.dump_ast());                } catch(e:*) {                    trace('!!!parse error:', e);                }                try {                    code_result = parser.codegen();                    trace('CODE:', code_result.join(" "));                } catch(e:*) {                        trace('!!!codegen error:', e);                }                try {                    var v:VM = new VM();                    v.system_dicts[0].Point = flash.geom.Point; // for testing native new                    v.system_dicts[0].Sprite = flash.display.Sprite; // for testing 0-argument native new                    v.load(code_result);                    if (spec.assertions.inject_globals)  {                      v.inject_globals(spec.assertions.inject_globals);                    }                    v.run();                } catch(e:*) {                    trace('!!!vm error:', e);                }                         try {                    if (spec.assertions.hasOwnProperty('trace')) {                        test = 'trace';                        pass = pass && v.dbg_traces[0] == spec.assertions.trace;                        result(pass, "Expected trace `" +                         spec.assertions.trace + '`:' + typeof(spec.assertions.trace) +                        ", got `" + v.dbg_traces[0] + '`:' + typeof(v.dbg_traces[0]));                    }                    } catch(e:*) {                        throw new Error('!!!trace error: ', e);                    }                    try {                                 if (spec.assertions.hasOwnProperty('globals')) {                                test = 'globals ' /*                                trace('test v.globals: ' + Inspector.inspect(v.globals) + ' vs expectation:     ' + Inspector.inspect(spec.assertions.globals));*/                                pass = pass && structureContains(v.vm_globals, spec.assertions.globals);                                result(pass, "Expected: " + Inspector.inspect(spec.assertions.globals) + ", got:" + Inspector.inspect(v.vm_globals));                            }                        } catch(e:*) {                            throw new Error('!!!globals error: ' + e);                        }              } catch (e:*) {        trace("!!!Broken test code caused exception");        result(false, e.toString());      }      end_test();    }        /*-------------- specs --------------- */     public function init_specs():void {      /***********************************************************      **  Testing...      ************************************************************/      spec('var x = 1; trace(x);', {parse:'[(var [(= x 1 ), ]  ), ]'}); // fails!!  var x = 1 compiles to nothing      spec('x = 1; trace(x);', {        parse:  '[(= x 1 ), (@CALL trace [x, ] ), ]',        code:   'LIT 1 LIT x PUT DROP VAL trace MARK VAL x ARRAY CALL'      }); // works    // SOURCE: var x = 1;    // AST:  [(var [(= x 1 ), ]  ), ]      spec('function f() { trace("it works!"); } f();',  {              parse:'[(function f [] [(@CALL trace [it works!, ] ), ]), (@CALL f [] ), ]',             code:'LIT f MARK ARRAY LIT VAL,trace,MARK,LIT,it works!,ARRAY,CALL DEF VAL f MARK ARRAY CALL',             trace:"it works!"       }); //[(var [(= f (function anon0 [] [(@CALL trace [it works!, ] ), ]) ), ]  ), (@CALL f [] ), ]            spec('var f = function() { trace("it works!"); }; f();',  {              parse:'[(= f (function [(trace "it works")])) (@call f)]', // or something like that; FIXME             // code: ' { function def } LIT f PUT DROP       MARK ARRAY  { function ref } CALL             code:'                          MARK ARRAY LIT VAL,trace,MARK,LIT,it works!,ARRAY,CALL DEF VAL f MARK ARRAY CALL',             trace:"it works!"       });            return;      /***********************************************************      **  Arithmetic and assignment      ************************************************************/            // assignment      spec('x=1;', {                      parse:'[(= x 1)]',                      code:'# 1 # x put',                      globals:{x:1}                  });      // arithmetic                  spec('y=2+2;', {                  parse:'[(= y (+ 2 2))]',                  code:'# 2 # 2 add # y put',                  globals:{y:4}                });      spec('x = (1 + 2) * 3;', {                          parse: "[(= x (* (+ 1 2) 3))]",                          code: '# 1 # 2 add # 3 mul # x put',                          globals: {x:9}                  });      spec('trace( 1 + 2 * 3 / 4 % 5);', {                            parse: "[(call trace [(+ 1 (% (/ (* 2 3) 4) 5))])]",                            code: '# trace [ # 1 # 2 # 3 mul # 4 div # 5 mod add ] call', // tbd return has no meaning in this context                            trace: 1 + 2 * 3 / 4 % 5                  });      //  - , unary minus      spec('trace(111 - 11);',                    {                     parse:'[(call trace [(- 111 11)])]',                     code: '# trace [ # 111 # 11 sub ] call',                     trace: 100                    }                  );      spec('trace(-1);', {                    parse: "[(call trace [(- 1)])]",                     code: '# trace [ # 1 neg ] call',                    trace:-1                  });      // arithmetic / %       spec('trace(10 % 3);',                    {                     parse:'[(call trace [(% 10 3)])]',                     code: '# trace [ # 10 # 3 mod ] call',                     trace: 1                    }                  );      spec('trace(10 / 3);',                    {                     parse:'[(call trace [(/ 10 3)])]',                     code: '# trace [ # 10 # 3 div ] call',                     trace: 10/3                    }                  );      // multiple assignment    spec('x = y = z = 2 + 3; y = y + 1;', { globals: {x:5, y:6, z:5}});    // modifying assignment    spec('w = x = y = z = 2; w += 2; x -= 2; y /= 2; z *= 3;', { globals: {w:4, x:0, y:1, z:6} })      // spec("x = y = 3; trace(x + y);",       //   {      //    parse: "[(= x (= y 3)]",      //    code: '# x # y 3 set set ',      //    globals:{x:3,y:3},      //    trace:6      //   }      // );      // +=      // /=      // *=      // %=        // arithmetic + *      // for      /***********************************************************      **  Control structures: if-elseif-else      ************************************************************/      spec("x = 3; if(x==3){y=5;} z = 4;",                     {                     parse: "[(= x 3),(if (== x 3) [(= y 5)])]",                     code: '# 3 # x put $ x # 3 eq jumpfalse 5 # 5 # y put',                     globals:{x:3,y:5, z:4}                    }                  );      spec("x = 3; y = 0; if(x==99){y=5;} z = 3;",                     {                     parse: "[(= x 3),(= y 0),(if (== x 99) [(= y 5)])]",                     code: '# 3 # x put # 0 # y put $ x # 99 eq jumpfalse 5 # 5 # y put',                     globals:{x:3, y:0, z:3}                    }                  );      spec('if(0) { x = 1; } else {x = 2; } y = 3;',                    {                      parse: '[(if 0 [(= x 1)] [(= x 2)])]',                      code: '# 0 jumpfalse 7 # 1 # x put jump 4 # 2 # x put',                      globals:{x:2, y:3}                    }                  );      spec('if(1) { x = 1; } else {x = 2; } z = 3;',                    {                      parse: '[(if 1 [(= x 1)] [(= x 2)])]',                      code: '# 1 jumpfalse 7 # 1 # x put jump 4 # 2 # x put',                      globals:{x:1, z:3}                    }                  );      spec(                    "if(0){x=1;} else if (1) {x=10;} else if(2) {x=100;} else { x = 1000; } z = 3;",                    {                       parse: "[(if 0 [(= x 1)] (if 1 [(= x 10)] (if 2 [(= x 100)] [(= x 1000)])))]",                      code: "# 0 jumpfalse 7 # 1 # x put jump 26 # 1 jumpfalse 7 # 10 # x put jump 15 # 2 jumpfalse 7 # 100 # x put jump 4 # 1000 # x put",                      globals: {x:10, z:3}                    });      /***********************************************************      **  constants: true false      ************************************************************/      spec('trace(true);', {parse: '[(call trace [(true )])]', code:'# trace [ # true ] call', trace:true});      spec('trace(false);', {parse: '[(call trace [(false )])]', code:'# trace [ # false ] call', trace:false});      /***********************************************************      **  Dot notation indexing      ************************************************************/      // indexing      spec('y = a.b.c;',                     {                      inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= y (. (. a b) c))]',                      code:"$ a # b dot # c dot # y put", // fixme;  b=1; a = { b:3 }; a[b] will access a[3]                       globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}, y:'value of a.b.c'}                    });      spec('a.b.c = d;',                    {                      inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= (. (. a b) c) d)]',                      code:'$ d $ a # b dot # c PUTINDEX',                      globals:{d:'value of d', a:{b:{c:'value of d'}}}                    });      // make sure a.b.c doesn't act like a[b].c      spec('b=12; a.b.c = d;',                    {                                inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= b 12),(= (. (. a b) c) d)]',                      code:'# 12 # b put $ d $ a # b dot # c PUTINDEX',                          globals:{d:'value of d', a:{b:{c:'value of d'}}}                    });      /****************************************************************      **  Shortcut logic operators && ||  (shortcutting doesn't work though)      *****************************************************************/      // logic      spec('x = 1; y = 0; trace(x && y);',                  {                   parse:'[(= x 1),(= y 0),(call trace [(&& x y)])]',                   code: '# 1 # x put # 0 # y put # trace [ $ x $ y and ] call',                   trace: 0                  }                );      spec('x = 1; y = 0; trace(x || y);',                  {                   parse:'[(= x 1),(= y 0),(call trace [(|| x y)])]',                   code: '# 1 # x put # 0 # y put # trace [ $ x $ y or ] call',                   trace: 1                  }                );      /***********************************************************      **  Variable scoping      ************************************************************/      //locals shadow globals          spec('x = 1; function f(x) { y = x; } f(2);',                  {                   parse:'[(= x 1),(function f [x] [(= y x)]),(call f [2])]',                   code: '# 1 # x put # f [ # x ] { $ x # y put } def # f [ # 2 ] call',                   globals: {x:1, y:2}                  }                );      // only defined locals shadow globals      spec('x = 1; function f(x,y) { y = x; } f(2);',                  {                   parse:'[(= x 1),(function f [x,y] [(= y x)]),(call f [2])]',                   code: '# 1 # x put # f [ # x # y ] { $ x # y put } def # f [ # 2 ] call',                   globals: {x:1}                  }                );      spec('function f(x) { a = x; y(x * 2); }  function y(x) { b = x; } f(1);',                   {                      globals:{a:1, b:2}                  }                );      spec('trace(!true);',                   {                     parse:'[(call trace [(! (true ))])]',                    code:'# trace [ # true not ] call',                    trace:false                  }                );      // while      spec('x = 0; i = 10; while(i>0) { i = i - 1; x = x + 2; }',                {                  parse:'[(= x 0),(= i 10),(while (> i 0) [(= i (- i 1)),(= x (+ x 2))])]',                  code:'# 0 # x put # 10 # i put $ i # 0 gt jumpfalse 18 $ i # 1 sub # i put $ x # 2 add # x put jump -25',                  globals:{x:20,i:0}                });     // local var, when assigned to, shadows global     spec('y=0; function f(x) { var y,z; y = x; z = y * 2; trace(z); } f(3);',      {          globals: { y:0 },          trace:6      });return;        /***********************************************************        **  Tests for error conditions        ************************************************************/              // invalid expression statement              spec("w = x = y = z = 2; \n w += 2; \n x -= 2; \n y /= 2; \n invalid_expression + 1; \n z *= 3;\n", { } )              // semicolon missing              spec("w = x\ny=z;", {});              // weird initializer              spec("x += y", {});              // try to redefine var              spec("var x = 1; function x() { trace(2); }", {});              // but this is okay, right?              spec("var x = 1; function y() { trace(2); }", {});                      // local vars shadow globals              spec('y=0; function f(x) { var y,z; y = x; z = y * 2; z2=z; trace(z); } f(3);',                {                    globals: { y:0, z2:6 },                    trace:6                });                    // excess args are ignored              spec('y=0; function f(x) { var z; trace(z); y = x * 2; } f(3,4,5,6,7,8,9);',                {                    globals: { y:6 },                    trace:undefined                });                   // args are passed              spec('y=0; function f(a, b, c) { var x, y, z; trace(a+b+c); } f(4,5,6);',                {                    globals: { y:0 },                    trace:15                });                    // native new with arguments              var p:Point = new Point(2,4); p.normalize(1);              spec('p = new Point(2, 4);  p.normalize(1); trace(p.x);', {globals:{p:{x:p.x,y:p.y}}, trace:p.x});              // 0-argument native new              spec('s = new Sprite(); s.x = 32; trace(s.x);', {trace:32});                       // fibonacci test -- recursion, return values              spec('function fib(n) { if(n<=1) { return 1; }  return fib(n-1) + fib(n-2); }  x = fib(10); trace(x); }', {trace:89});            }  }}