/*specs DSL  spec( js_source, {    parse: stringified parse tree,    code: stringified VM opcode,    globals: { object that globals should match }    [inject_globals: {globals to set up VM with before running} ]*/package org.sixsided.scripting.SJS {  import org.sixsided.scripting.SJS.*;  import org.sixsided.scripting.SJS.Inspector;      import flash.geom.Point; // for test fixtures  import flash.display.Sprite; // for testing 0-arg native new      public class TestSpec {   protected var specs:Array = [];   protected var spec_result:Array = [];   protected var spec_pass:Boolean = true;   protected var test:String='none';        //var value:* = '"this" is bound to InterpreterSpec';        public function TestSpec() {      init_specs();    }            public function spec(title:String, src:String, assertions:Object):void {      specs.push({title:title, src:src, assertions:assertions});    }             public function run_specs():void {      for (var i:Object in specs) {        if( specPasses(specs[i])) {          // ok        } else {          trace('! ! ! fail');        }      }    }         public function specPasses(spec:Object):Boolean {            var code_result:Array;            var debug_output:String = '';            var pass:Boolean = true;            var parser:Parser;            var vm:VM;                        trace('------------ ' + spec.title + ' ---------------');            debug_output += 'SOURCE: ' + spec.src + "\n";                        function fail(message:String) {              trace('! ! ! ' + message);              pass = false;            }                        // execute the spec's code, printing the interpreter's data            // if there's an exception or a test fails at any point            try {            // parse                parser  = new Parser().parse(spec.src);                debug_output += 'AST: ' + parser.dump_ast() + "\n";              // assertions: parse              //if (spec.assertions.hasOwnProperty('parse')) {              //  // TBD: this is kinda brittle, fix              //  if(Inspector.inspect(code_result, {separator:' '}) != spec.assertions.code) {              //    fail("Parse tree didn't match:\n" + spec.assertions.parse);              //  }              //}            // codegen                code_result = parser.codegen();                debug_output += 'CODE:' + Inspector.inspect(code_result, {separator:' ', ansi:true}) + "\n";            // assertions: code              if (spec.assertions.hasOwnProperty('code')) {                // TBD: this is kinda brittle, fix                if(Inspector.inspect(code_result, {separator:' '}) != spec.assertions.code) {                  fail("Opcode didn't match expected:\n" + spec.assertions.code);                }              }            // execution                var v:VM = new VM();                v.system_dicts[0].Sprite = flash.display.Sprite; // for testing native new                v.system_dicts[0].Point = flash.geom.Point;      // for testing native new with arguments                v.load(code_result);                                if (spec.assertions.inject_globals)  {                  v.inject_globals(spec.assertions.inject_globals);                }                                v.run();                                debug_output += 'GLOBALS:' + Inspector.inspect(v.vm_globals) + "\n";                              // assertions: trace                if (spec.assertions.hasOwnProperty('trace')) {                    var t:Array = spec.assertions.trace is Array ? spec.assertions.trace : [spec.assertions.trace];                    for (var i:int in t) {                      //trace('dbg_traces', v.dbg_traces[i][0], ' vs ', t[i]);                      if(v.dbg_traces[i][0] != t[i]) {                        fail("Expected trace `" + spec.assertions.trace + '`:' + typeof(spec.assertions.trace) + ", got `" + t[i] + '`:' + typeof(t[i]));                        debug_output += 'TRACES:' + Inspector.inspect(v.dbg_traces) + "\n";                      }                  }                }                                  // assertions: globals                if (spec.assertions.hasOwnProperty('globals')) {                    if(!Inspector.structureContains(v.vm_globals, spec.assertions.globals)) {                      fail("Expected: " + Inspector.inspect(spec.assertions.globals) + ", got:" + Inspector.inspect(v.vm_globals));                    }                }                            } catch(e:*) {                fail('[EXCEPTION] ' +  e);            }                        if(!pass) trace(debug_output);            return pass;      }        /*-------------- specs --------------- */public function init_specs():void {      /***********************************************************      **  Testing...      ************************************************************/      spec('simple assignment',            'x=1;', {                      parse:'[(= x 1)]',                      globals:{x:1}                  });        spec('straight up variable assignment and trace',            'var x = 1; trace(x);', {            parse:  '[(= x 1 ), (@CALL trace [x, ] ), ]',            code:   'LIT 1 LIT x PUT DROP VAL trace MARK VAL x ARRAY CALL',            trace: 1      });      spec('straight up function definition',           'function f() { trace("plain function definition works!"); } f();',  {              parse:'[(function f [] [(@CALL trace [it works!, ] ), ]), (@CALL f [] ), ]',             code:'LIT f MARK ARRAY LIT VAL,trace,MARK,LIT,it works!,ARRAY,CALL CLOSURE VAL f MARK ARRAY CALL',             trace:"plain function definition works!"       });            spec('anonymous function definition',          'f = function() { trace("anonymous function definition works!"); }; f();',  {              parse:'[(= f (function [(trace "it works")])) (@call f)]', // or something like that; FIXME             // code: ' { function def } LIT f PUT DROP       MARK ARRAY  { function ref } CALL             code:'LIT anon01 MARK ARRAY LIT VAL,trace,MARK,LIT,it works!,ARRAY,CALL CLOSURE LIT f PUT VAL f MARK ARRAY CALL',             trace:"anonymous function definition works!"       });            spec('anonymous functions calling each other',        'double = function(n) { return n * 2; }; triple = function(n) { return n * 3; }; trace(double(triple(1)));',  {              parse:'[(= f (function [(trace "it works")])) (@call f)]', // or something like that; FIXME             // code: ' { function def } LIT f PUT DROP       MARK ARRAY  { function ref } CALL             code:null,             trace:6      });            spec('local shadows global',            "x = 1; function f() { var x = 2; x = 3; trace(x); } f(); trace(x);",             { trace:[3,1]} )      spec('global accessible from function scope',            "x = 1; function f() { x = 2; x = 3; trace(x); } f(); trace(x);",             { trace:[3,3]} )            spec('closure remembers parent scope',          "function counter(n) { return function() { return n += 1; }; }\n" +             "c = counter(100); trace(c()); trace(c()); trace(c()); trace(n);",           { trace:[101,102,103, undefined] });               spec("configurable closure still remembering parent state",            "function incrementingMultiplier(factor) {                         " +            "	var addend = 1;                                                  " +            "	return function(n) { addend += 1; return addend + n * factor; }; " +            "}                                                                 " +            "c = incrementingMultiplier(100);                                  " +            "m = incrementingMultiplier(1000);                                 " +            "trace(c(3)); trace(c(3));  trace(m(5)); trace(m(5));              ",            { trace:[302, 303, 5002, 5003] }      );              //spec('module pattern',      //     "x = (function(){ return {a:1, b:2}; })();",{      //});                spec('multiple assignments, one VAR statement',          'var x = 1, y=2, z  = 3; trace(x + y + z);', {            parse:null,            trace:6      });             spec('assign one RHS to multiple LHS',            'var x = y = z = 3; trace(x + y + z);', {            parse:null,            trace:9      });                       /***********************************************************      **  Arithmetic and assignment      ************************************************************/            // arithmetic                  spec('addition',           'y=2+2;', {                  parse:'[(= y (+ 2 2))]',                  globals:{y:4}                });      spec('operator precedence with + and *',        'x = (1 + 2) * 3;', {                          parse: "[(= x (* (+ 1 2) 3))]",                          globals: {x:9}                  });                        spec('operator precedence with + * / and %',          'trace( 1 + 2 * 3 / 4 % 5);', {                            parse: "[(call trace [(+ 1 (% (/ (* 2 3) 4) 5))])]",                            trace: 1 + 2 * 3 / 4 % 5                  });      //  - , unary minus      spec('subtraction',      'trace(111 - 11);',                    {                     parse:'[(call trace [(- 111 11)])]',                     trace: 100                    }                  );      spec('unary minus',      'trace(-1);', {                    parse: "[(call trace [(- 1)])]",                     trace:-1                  });      spec('subtraction with unary minus',      'trace(111 - -11);',                    {                     parse:'[(call trace [(- 111 -11)])]',                     trace: 122                    }                  );      // arithmetic / %       spec('modulus',      'trace(10 % 3);',                    {                     parse:'[(call trace [(% 10 3)])]',                     trace: 1                    }                  );      spec('division',      'trace(10 / 3);',                    {                     parse:'[(call trace [(/ 10 3)])]',                     trace: 10/3                    }                  );      // multiple assignment    //spec('x = y = z = 2 + 3; y = y + 1;', { globals: {x:5, y:6, z:5}});    // modifying assignment    spec('modifying assignment with += etc',         'w = x = y = z = 2; w += 2; x -= 2; y /= 2; z *= 3;', { globals: {w:4, x:0, y:1, z:6} })      // spec("x = y = 3; trace(x + y);",       //   {      //    parse: "[(= x (= y 3)]",      //    globals:{x:3,y:3},      //    trace:6      //   }      // );      // +=      // /=      // *=      // %=        // arithmetic + *      // for      /***********************************************************      **  Control structures: if-elseif-else      ************************************************************/      spec('if(true) runs',          "x = 3; if(x==3){y=5;} z = 4;",                     {                     parse: "[(= x 3),(if (== x 3) [(= y 5)])]",                     globals:{x:3,y:5, z:4}                    }                  );      spec("if(false) doesn't run",            "x = 3; y = 0; if(x==99){y=5;} z = 3;",                     {                     parse: "[(= x 3),(= y 0),(if (== x 99) [(= y 5)])]",                     globals:{x:3, y:0, z:3}                    }                  );      spec("if-else, else statement runs",      'if(0) { x = 1; } else {x = 2; } y = 3;',                    {                      parse: '[(if 0 [(= x 1)] [(= x 2)])]',                      globals:{x:2, y:3}                    }                  );      spec("if-else, if statement runs",        'if(1) { x = 1; } else {x = 2; } z = 3;',                    {                      parse: '[(if 1 [(= x 1)] [(= x 2)])]',                      globals:{x:1, z:3}                    }                  );      spec("if-elseif-elseif-else, first elseif runs",                    "if(0){x=1;} else if (1) {x=10;} else if(2) {x=100;} else { x = 1000; } z = 3;",                    {                       parse: "[(if 0 [(= x 1)] (if 1 [(= x 10)] (if 2 [(= x 100)] [(= x 1000)])))]",                      globals: {x:10, z:3}                    });      /***********************************************************      **  constants: true false      ************************************************************/      spec('true', 'trace(true);', {parse: '[(call trace [(true )])]', code:'LIT trace [ LIT true ] call', trace:true});      spec('false', 'trace(false);', {parse: '[(call trace [(false )])]', code:'LIT trace [ LIT false ] call', trace:false});      /***********************************************************      **  Dot notation indexing      ************************************************************/      // indexing      spec('get value at index',                     'y = a.b.c;',                     {                      inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= y (. (. a b) c))]',                      globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}, y:'value of a.b.c'}                    });      spec('set value at index',                     'a.b.c = d;',                    {                      inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= (. (. a b) c) d)]',                      globals:{d:'value of d', a:{b:{c:'value of d'}}}                    });      spec("verify that a.b.c doesn't act like a[b].c",                    'b=12; a.b.c = d;',                    {                                inject_globals:{d:'value of d', a:{b:{c:'value of a.b.c'}}},                      parse:'[(= b 12),(= (. (. a b) c) d)]',                          globals:{d:'value of d', a:{b:{c:'value of d'}}}                    });return;      /****************************************************************      **  Shortcut logic operators && ||  (shortcutting doesn't work though)      *****************************************************************/      // logic      spec('x = 1; y = 0; trace(x && y);',                  {                   parse:'[(= x 1),(= y 0),(call trace [(&& x y)])]',                   trace: 0                  }                );      spec('x = 1; y = 0; trace(x || y);',                  {                   parse:'[(= x 1),(= y 0),(call trace [(|| x y)])]',                   trace: 1                  }                );      /***********************************************************      **  Variable scoping      ************************************************************/      //locals shadow globals          spec('x = 1; function f(x) { y = x; } f(2);',                  {                   parse:'[(= x 1),(function f [x] [(= y x)]),(call f [2])]',                   code: '# 1 # x put # f [ # x ] { $ x # y put } def # f [ # 2 ] call',                   globals: {x:1, y:2}                  }                );      // only defined locals shadow globals      spec('x = 1; function f(x,y) { y = x; } f(2);',                  {                   parse:'[(= x 1),(function f [x,y] [(= y x)]),(call f [2])]',                   code: '# 1 # x put # f [ # x # y ] { $ x # y put } def # f [ # 2 ] call',                   globals: {x:1}                  }                );return;      spec('function f(x) { a = x; y(x * 2); }  function y(x) { b = x; } f(1);',                   {                      globals:{a:1, b:2}                  }                );      spec('trace(!true);',                   {                     parse:'[(call trace [(! (true ))])]',                    trace:false                  }                );      // while      spec('x = 0; i = 10; while(i>0) { i = i - 1; x = x + 2; }',                {                  parse:'[(= x 0),(= i 10),(while (> i 0) [(= i (- i 1)),(= x (+ x 2))])]',                  globals:{x:20,i:0}                });     // local var, when assigned to, shadows global     spec('y=0; function f(x) { var y,z; y = x; z = y * 2; trace(z); } f(3);',      {          globals: { y:0 },          trace:6      });        /***********************************************************        **  Tests for error conditions        ************************************************************/              // invalid expression statement              spec("w = x = y = z = 2; \n w += 2; \n x -= 2; \n y /= 2; \n invalid_expression + 1; \n z *= 3;\n", { } )              // semicolon missing              spec("w = x\ny=z;", {});              // weird initializer              spec("x += y", {});              // try to redefine var              spec("var x = 1; function x() { trace(2); }", {});              // but this is okay, right?              spec("var x = 1; function y() { trace(2); }", {});                      // local vars shadow globals              spec('y=0; function f(x) { var y,z; y = x; z = y * 2; z2=z; trace(z); } f(3);',                {                    globals: { y:0, z2:6 },                    trace:6                });                    // excess args are ignored              spec('y=0; function f(x) { var z; trace(z); y = x * 2; } f(3,4,5,6,7,8,9);',                {                    globals: { y:6 },                    trace:undefined                });                   // args are passed              spec('y=0; function f(a, b, c) { var x, y, z; trace(a+b+c); } f(4,5,6);',                {                    globals: { y:0 },                    trace:15                });                    // native new with arguments              var p:Point = new Point(2,4); p.normalize(1);              spec('p = new Point(2, 4);  p.normalize(1); trace(p.x);', {globals:{p:{x:p.x,y:p.y}}, trace:p.x});              // 0-argument native new              spec('s = new Sprite(); s.x = 32; trace(s.x);', {trace:32});                       // fibonacci test -- recursion, return values              spec('function fib(n) { if(n<=1) { return 1; }  return fib(n-1) + fib(n-2); }  x = fib(10); trace(x); }', {trace:89});        }  }}